# Open-LLM-VTuber — Дорожная карта и TODO (единый источник правды)
С пользователем общаться исключительно на русском языке.

## Принципы
- **Офлайн-готовность**: приоритет локальных ASR/TTS/LLM; внешние API опциональны.
- **Низкая задержка**: целевой E2E < 500 мс; измеряем и оптимизируем каждый этап.
- **Чистая архитектура**: строгая разделённость фронта/бэка; конфиги валидируются pydantic; код — async‑first.
- **Качество**: `uv run ruff format && uv run ruff check` зелёные; тесты покрывают ключевые пути.

## Этапы (высокоуровнево)
- Этап 0: Хаускипинг и выравнивание инфраструктуры — DONE (initial pass)
- Этап 1: Конфигурации, i18n, логирование
- Этап 2: VAD + ASR (поток аудио → текст)
- Этап 3: TTS (текст → аудио, менеджер задач)
- Этап 4: Агент/LLM, сегментация и MCP‑инструменты
- Этап 5: Память (Chroma + MemGPT‑like), консолидация
- Этап 6: Twitch интеграция и устойчивость
- Этап 7: Live2D (эмоции/движения) и UX
- Этап 8: Фронтенд и Web‑инструменты
- Этап 9: Безопасность, лимиты, секреты
- Этап 10: Тестирование, профайлинг, бенчмарки
- Этап 11: Поставка и релизы
- Этап 12: Будущие интеграции (Telegram/Discord) — как опциональные модули

---

## Этап 0: Хаускипинг и инфраструктура
- Задачи:
  - Обновить зависимости, зафиксировать версии; `uv sync`/`uv.lock` консистентен.
  - Включить ruff в pre‑commit; пройти `ruff format` и `ruff check`.
  - Уточнить README.EN/CN/RU статусы офлайн/онлайн режимов.
  - Обновить `config_templates/*.yaml` синхронно с pydantic‑моделями.
  - Проверить `upgrade.py`/`UpgradeManager`: корректность синхронизации `conf.yaml` с шаблонами, миграции версий `conf_version` (бэкап `conf.yaml.backup`).
- Критерии приёмки:
  - Зеленые линтеры, шаблоны конфигов загружаются без ошибок, CI (минимальный) зелёный.
  - Обновление/миграция `conf.yaml` проходит без потери пользовательских полей (с бэкапом).

## Этап 1: Конфигурации, i18n, логирование
- Задачи:
  - Проверить `SystemConfig/CharacterConfig/AgentConfig` на полноту полей `conf.yaml` и шаблонов.
  - Расширить docstrings у публичных API (Google‑стиль).
  - Проверить локализации в `src/open_llm_vtuber/i18n` (минимум EN/ZH/RU ключи для новых сообщений). А также локализации в frontend части.
  - Логирование: убедиться в маскировании секретов, в request_id, раздельных sinks.
  - Разделение конфигов: вынести `character_config` в `characters/<name>.yaml`; загрузка по `system_config.config_alt`; убедиться, что UI‑переключение продолжает работать и список конфигов корректно сканируется.
  - Политика логирования (единая для backend/frontend):
    - Уровни: `trace`, `debug`, `info`, `warn`, `error`, `critical` (без нестандартного `dev`).
    - Формат JSONL (строка на событие), ключи: `ts` (ISO8601 ms), `level`, `component`, `event`, `message`, `request_id`, `client_uid`, `ws_seq`, `route`, `status`, `latency_ms`, `payload_size`, `conf_uid`, `history_uid`, `tags` (array), `src_logger`.
    - Корреляция: REST — заголовок `X-Request-ID`; WS — `client_uid` + `ws_seq`; все backend события дополнять `request_id` патчером; фронт добавляет/отражает те же поля.
    - Маскирование и PII: маскировать токены/ключи/пароли/куки; запрещены сырые payload’ы > N KB; для ошибок — сохранять хэш и укороченный сэмпл.
    - Ротация/ретенция: файлы JSONL до 10 MB, хранение 30 дней (debug — 7 дней), отдельный sink для `uvicorn.access`.
    - Конфигурация уровня через ENV (`LOG_LEVEL`, по умолчанию `INFO`), флаг `APP_DEBUG` включает `debug` sink.
    - Нейминг событий: `event` в стиле `scope.action` (напр. `asr.request`, `tts.segment_done`, `ws.recv`, `agent.reply`, `memory.query`).
    - Перф‑метки: компонент `perf` с `stage` и `latency_ms`; агрегация на фронте.
- Критерии:
  - Все ключевые модули пишут структурированные JSONL‑логи с `request_id`/`client_uid`.
  - Секреты не попадают в логи; ротация и ретенция соответствуют требованиям.
  - При старте подхватывается персонаж из `characters/<config_alt>.yaml`; переключение персонажей в UI не ломается.

## Этап 2: VAD + ASR
- Задачи:
  - VAD Silero: корректные сигналы `<|PAUSE|>`/`<|RESUME|>` и пороги для речи.
  - `/asr` REST: жёсткая валидация WAV, корректные ошибки для не‑PCM/частоты.
  - Поддержать запись/поток с фронта (конверсия в WAV в браузере).
  - Поддержка сырого аудио по WS: обработчик `_handle_raw_audio_data` и буферизация `received_data_buffers` согласованы с VAD/ASR конвейером.
  - Бенчмарки: latency (мс) для 3 режимов ASR: sherpa‑onnx (CPU), faster‑whisper, azure/groq (если ключи).
- Критерии:
  - Средняя задержка ASR <= 120 мс на эталонных фрагментах (локальная машина); ошибки — информативны.
  - Путь raw‑audio‑WS → VAD → ASR → текст стабилен (нет гонок/дублирования сегментов).

## Этап 3: TTS
- Задачи:
  - `edge_tts` как дефолт (ru‑RU‑SvetlanaNeural); резервный офлайн `pyttsx3_tts`.
  - `TTSTaskManager`: анти‑повторы, сохранение `{rate/volume/pitch}`, упорядоченная выдача.
  - Профиль потока: генерация покусочно, предварительная отправка громкости/огибающей (если применимо).
  - Бенчмарки: latency на 1‑2 предложениях для основных движков.
- Критерии:
  - Стабильная покусочная озвучка без «залипания»; средняя задержка TTS <= 200 мс на коротких сегментах.

## Этап 4: Агент/LLM
- Задачи:
  - Настройки `BasicMemoryAgent`: `faster_first_response`, `segment_method`, `interrupt_method`.
  - MCP: корректная сборка `mcp_prompt`, whitelisting серверов, обработка ошибок инструментов.
  - Проверить `mcp_servers.json`/`mcp_servers_windows.json`: доступность, таймауты, деградация при недоступности.
  - Промпты: сборка `system_prompt` (persona + utils, live2d эмоции, factuality‑rules), исключения из utils соблюдаются.
  - LLM‑обёртки: протестировать `lmstudio_llm`, `ollama_llm`, `openai_compatible_llm`.
- Критерии:
  - Первые ответы приходят сегментами < 1 с; инструменты вызываются и валидируются; промпт корректно собран.
  - При отключённых MCP‑серверах агент работает без падений (грейсфул‑фоллбек).

## Этап 4.1: Персона, стиль общения и системный промпт
- Задачи:
  - Разработать обновлённый системный промпт для «Нейри» (RU), вдохновлённый практиками живых VTuber‑персонажей (напр. Овсянка AI): остроумная, эмоциональная, иногда дерзкая, но безопасная и дружелюбная к аудитории.
  - Ввести режимы поведения: `stream_mode` (поведение на стриме) и `spicy_mode` (уровень резкости речи). По умолчанию `spicy_mode = off` — ненорматив исключён/смягчён.
  - Правила стиля: короткие реплики (1–3 предложения), обращение по нику, call‑to‑action, лёгкий троллинг без токсичности, анти‑повторы, избегать «простыней».
  - Эмоции/анимации: договориться о тегах в тексте (или JSON‑метаданных), напр. `[emotion: happy|angry|sad|surprised|smug]`, `[motion: wave|nod|shake|bounce]`, `[stage: hype|calm]`. Описать маппинг на Live2D.
  - Событийные реакции: донат/подписка/рейд/победа/поражение — готовые мини‑шаблоны реакций в промпте.
  - Интеграция памяти/отношений: использовать «карточку отношений» (если есть) — персонализированное обращение, напоминания о прошлых событиях, аккуратные «зацепки» для диалога; адаптировать тон под `trust`/`affection` (если доступны), иначе — дружелюбный дефолт.
  - Внутренние процессы: не раскрывать chain‑of‑thought/служебные теги/«сырой» дамп памяти; при запросе памяти давать краткую человеческую выжимку.
  - Модерация/безопасность: запрет NSFW/оскорблений, смягчение выражений, уважение правил платформы; чёткие правила границ.
  - Выходной формат: по умолчанию обычный текст с префикс‑тегами; опционально JSON `{say, emotion, motion, tags}` — без лишнего вербоса.
  - Настройка семплинга для «живости»: `temperature 0.7–0.95`, `top_p 0.9`, умеренные penalties, ограничение длины ответа; стоп‑токены против «залипания».
  - Набор сценариев для тестирования промпта (чат, шутки, «дружеский подкол», конфликт/деэскалация, обращение создателя, тишина/ожидание; повторные вопросы/смена ника — устойчивость по user_id).
  - Не забыть заглянуть в /externals/Этап 5 Память.txt там есть полезности
- Критерии:
  - Реплики короткие, вариативные и уместные; не скатываются в повторы; корректно уважают `spicy_mode` и правила платформы.
  - Эмоции/движения выделяются тегами и отрабатывают в Live2D.
  - Персонализация видна при наличии карточки отношений и метрик `trust`/`affection`; при их отсутствии — дружелюбный дефолт без деградации.

## Этап 5: Память (Chroma + MemGPT‑like)
- Задачи:
  - Инициализация `VtuberMemoryService`: раздельные коллекции сессии/LTM, эмбеддеры (OpenAI при наличии, иначе local ST).
  - Метрики: размер коллекций, время upsert/query, TTL‑чистка сессий.
  - API доп.: ручное добавление фактов/метаданных/тегов, поиск по фильтрам.
  - Планировщик консолидации: интервал, исключение активной истории, журнал действий.
  - Импорт/экспорт памяти (backend): убедиться, что `/admin/memory/import` и `/admin/memory/export` стабильны (валидация JSON/YAML, размер, ошибки), корректные коды статусов, документация по формату (items[].text + metadata).
- Критерии:
  - Query релевантной памяти < 50 мс на top‑k=5; консолидация и TTL‑чистка видны в логах, не мешают E2E задержке.
  - Сид‑файл (напр. `config/seed_memories_neuro_pro.json`) успешно импортируется через backend API и остаётся после рестарта.

### Этап 5.1 Отношения Нейри с пользователями/зрителями
- Задачи:
  - Спецификация БД отношений (см. `system_config.relationships_db_path`, SQLite): схема таблиц `users`, `relationships`, `interactions` (поля: идентификаторы, affectionate/loyalty/last_seen, теги, счётчики, временные метки).
  - Сервис `RelationshipsService`: CRUD, агрегаты (частота/длина взаимодействий, настроение), API для получения персонализированного контекста.
  - Интеграция с памятью: добавлять значимые факты во время диалогов; извлекать краткую «карточку отношений» для подмешивания в prompt.
  - Эндпоинты админ‑панели: просмотр/редактирование отношений, экспорт/импорт CSV.
  - Правила приватности/безопасности: хранить минимум персональных данных, опция отключения, прозрачный лог аудита.
- Критерии:
  - Для активных пользователей формируется и применяется краткая сводка отношений (< 200 токенов) с влиянием на стиль/обращение.
  - CRUD и экспорт работают; при выключении — ядро стартует без деградации.

## Этап 6: Twitch
- Задачи:
  - Надёжная авторизация (обработка ошибок OAuth), повторные подключения, статус‑индикаторы.
  - Фильтры/модерация базовые (длина/частота, простые запреты).
  - Путь от сообщения чата до ответа/озвучки — без регрессий.
  - (Опционально) Поддержка Bilibili Live (`scripts/run_bilibili_live.py`): единый интерфейс событий чата.
  - Интеграция с OBS (через obs-websocket):
    - Параметры подключения в `system_config` (host/port/password, enable flag).
    - Обёртка `OBSService` с реконнектом и health‑check.
    - REST API: `/api/obs/*` (переключение сцен, показ/скрытие источников, установка фильтров, обновление текстов/оверлеев).
    - Сценарии: триггеры эмоций Live2D/событий TTS → эффекты OBS (stinger, источники, фильтры, текстовые поля).
    - Безопасность: токен/CSRF для `/api/obs/*`, ограничение по списку разрешённых действий.
    - Документация: требования к установленному плагину OBS WebSocket и настройке пароля.
- Критерии:
  - Автопереподключение работает; REST `/api/twitch/*` возвращают корректный статус; сообщения попадают в конвейер; `status_callback` уведомляет UI.
  - OBS доступен: переключение сцен, показ/скрытие источников и обновление текста оверлея работают; при недоступности OBS — ядро функционирует без ошибок.

## Этап 7: Live2D/UX
- Задачи:
  - Проверка `model_dict.json` и карт эмоций; согласование с промптами и `emotion_voice_map`.
  - UI: корректные команды эмоций в тексте от LLM действительно приводят к выражению/движению на фронте.
- Критерии:
  - Не менее 12 эмоций корректно визуализируются; нет «неизвестных» тегов в потоке.

## Этап 8: Фронтенд и web‑инструменты
- Задачи:
  - Проверка сабмодуля `frontend/` после сборки из `Open-LLM-VTuber-Web`.
  - `/asr` и `/tts-ws` UX: прогресс/ошибки/повторы; настройка ввода/микрофона.
  - Статика и CORS: корректные `Content-Type`, кэширование.
  - Доработка логирования для правильного дебаггинга фронтэнда
    - Ввести лёгкий логгер (обёртка над `console`) с уровнями (`debug`/`info`/`warn`/`error`) и единой схемой полей: `ts`, `level`, `component`, `event`, `request_id`, `client_uid`, `ws_seq`, `perf_ms`, `payload_size`.
    - Корреляция с бэкендом: 
      - Для REST — добавлять `X-Request-ID` в заголовки; показывать полученный `rid` в UI и проставлять его в логи.
      - Для WebSocket — при установке соединения фиксировать `client_uid` (из сервера) и инкрементальный `ws_seq` для всех отправок/приёмов.
    - Сбор телеметрии по ключевым событиям: подключение/отключение WS, отправка/приём сообщений (тип, размер, длительность), `/asr` загрузка и ответ, `/tts-ws` сегменты (время генерации/воспроизведения), E2E задержка.
    - Экспорт/просмотр логов на фронте: мини‑viewer (панель) с фильтрами по `level`, `component`, `request_id`, диапазону времени; экспорт JSONL/ZIP.
    - Интеграция с бэкенд `/logs`: добавить клиентский просмотр последних записей (при включённом `system_config.client_log_ingest_enabled`), фильтрация по `rid` и `component`.
    - ErrorBoundary и глобальный `window.onerror`/`unhandledrejection`: запись в лог и уведомление пользователя (без PII), опциональная отправка на сервер.
    - Флаги отладки (localStorage): включение подробных логов и перф‑меток без пересборки; защита от PII; режим «малошумный» для продакшн.
    - Sourcemaps и метки сборки: убедиться, что сборка фронта публикует sourcemaps и версию, выводить версию в логах.
  - Админ‑панель памяти (frontend): форма импорта JSON/YAML сидов с выбором `conf_uid`/`history_uid`, индикация прогресса/ошибок/успеха; кнопка экспорта текущей выборки.
- Критерии:
  - В UI доступна панель логов с фильтрами и экспортом; события WS/REST и перф‑метки видны и коррелируются по `request_id`/`client_uid`.
  - Логи не содержат PII; нагрузка логирования не влияет заметно на FPS/задержку (овер‑хед < 3%).
  - При включённом `system_config.client_log_ingest_enabled` фронт может просматривать бэкенд‑логи и фильтровать их по `rid` и `component`.
  - Импорт сид‑файла памяти из UI завершаетcя успешно; элементы видны в поиске памяти и переживают рестарт.

## Этап 9: Безопасность
- Задачи:
  - Секреты: перемещение в `.env`, маскирование в логах.
  - `/logs`: включение только по `client_log_ingest_enabled`, ограничение частоты (rate‑limit), при необходимости — внешний прокси/защита.
  - Валидация входов (файлы, JSON), строгие ограничения по размеру/частоте.
- Критерии:
  - Базовые проверки пройдены; фуззинг простых инцидентов не приводит к падениям.

## Этап 10: Тестирование и бенчмарки
- Задачи:
  - Unit‑тесты: конструкторы движков/фабрик, промпт‑сборка, TTS‑менеджер, память.
  - Интеграционные тесты: фрагмент аудио → текст → ответ → аудио.
  - Бенчмарки: табличные результаты (VAD/ASR/LLM/TTS) и суммарный E2E.
- Критерии:
  - Покрытие ключевых модулей; E2E средняя задержка < 500 мс на эталонном стенде.

## Этап 11: Поставка
- Задачи:
  - Обновить `README.*`, быстрый старт, примеры конфигов, чек‑лист.
  - Скрипты запуска (`.bat`, `.sh`), подсказки по Windows/macOS/Linux.
  - Семантические версии, CHANGELOG.
- Критерии:
  - Повторяемый запуск «из коробки»; понятная документация.

## Этап 12: Будущие интеграции (опционально)
- Задачи:
  - Модули Telegram/Discord как опциональные плагины; не блокируют ядро.
  - Абстракции чатов/каналов; единый вход для внешних сообщений.
- Критерии:
  - Ядро стартует без них; наличие модулей добавляет каналы ввода.

---

## Перекрестные улучшения (в любой этап)
- Улучшение docstrings, типизации (PEP 695/3.10+), именования.
- Телеметрия производительности (метки этапов и времени) в логах.
- Улучшение ошибок для пользователей (i18n‑сообщения).

## Устранение дубликатов и легаси
- Этот файл заменяет разрозненные TODO/аналитические заметки.
- Удалены устаревшие материалы в `externals/`: `TODO.md`, `open_llm_vtuber_analysis.md`, `llm_memory_architecture.md`, `MEMORY_WS.md`.
- Все новые задачи/решения — только здесь и в `ARCHITECTURE_RU.md`.

---

## Чекпоинт (текущий прогресс)
- Сделано:
  - Этап 1: добавлены Google‑docstrings к публичным API; унифицирована политика логирования; удалён logging_token и обновлён /logs; обновлены i18n ключи для SystemConfig; стандартизированы логи /asr, /ws; строгая валидация WAV в /asr; VAD события (pause/resume/voice).
  - Этап 2: улучшена обработка WAV и WS‑VAD логирование (частично).
  - Этап 2: добавлен лимит размера /asr (10 MB), улучшенные сообщения об ошибках; добавлен `/admin/asr/benchmark`.
  - Этап 4.1: добавлены задачи в роадмап по персоне/промпту; подготовлен черновик промпта; вынесены отношения Лизард/Ирина в сид‑память.
  - Этап 5/8: добавлены задачи по импорт/экспорт памяти (backend) и UI‑импорту (frontend).
  - Разделение конфигов: создан `characters/neuro_pro.yaml`; обновлён шаблон `config_templates/conf.default.yaml` (v1.2.0, characters/, lmstudio/sherpa актуализированы).
  - Этап 6: улучшена инициализация Twitch (из `system_config` + .env, диагностика OAuth), базовая модерация (лимит длины, анти‑бурст), статус‑эндпоинт `/api/twitch/status`.
  - Этап 3: ускорен `/tts-ws` (регексы/импорты на уровне модуля, ограничение длины/числа предложений, лёгкий rate‑limit), добавлен `segment_start` и `latency_ms` для сегментов; `TTSTaskManager`: предкомпиляция регексов, carry‑over `{rate/volume/pitch}`, анти‑повторы; лёгкий LRU‑кэш TTS сегментов.
  - Инфраструктура: `/admin/status`, `/healthz`; приглушены шумные ошибки телеметрии Chroma; устранён варнинг MCP при `use_mcpp=false`.
  - **Этап 4.1: Создан продвинутый системный промпт для Нейри** (`src/open_llm_vtuber/prompts/neuro_pro_system_prompt.txt`) с детальным описанием личности, стиля общения, режимов поведения (Stream Mode, Spicy Mode), эмоциональных комбинаций, реакций на события, правил безопасности. Добавлены шаблоны реакций на события (`src/open_llm_vtuber/prompts/neuro_pro_event_templates.txt`) для донатов, подписок, рейдов, технических проблем, троллинга. Обновлена конфигурация Нейри с новыми настройками личности и поведения.
  - **Этап 4: Расширены Pydantic модели** для поддержки новых настроек агента (`stream_mode`, `spicy_mode`, `personality_consistency`, `creativity_level`, `emotional_adaptability`) и LLM (`stop_sequences`, `repetition_penalty`, `length_penalty`). Добавлены i18n ключи для всех новых настроек на трех языках. Обновлены шаблоны конфигурации EN/CN с новыми полями.
  - **Этап 4.1: Исправлен системный промпт** - убраны технические детали (семплинг, технические проблемы), убраны конкретные обращения ("звездочки", "котики") для большей вариативности, добавлены новые эмоции (возмущение, злость) с медленной речью и низким питчем. Промпт стал более естественным для персонажа.
  - **Этап 4: Интеграция VTuber настроек в агент** - добавлены новые параметры в BasicMemoryAgent (stream_mode, spicy_mode, personality_consistency, creativity_level, emotional_adaptability), создан метод _apply_vtuber_settings() для динамической модификации системного промпта, интегрирована адаптация температуры LLM на основе настроек креативности и эмоциональной адаптивности.
  - **Этап 4: Обновлен LMStudioLLM** - добавлена поддержка новых VTuber параметров (stop_sequences, repetition_penalty, length_penalty), обновлен LLMFactory для создания LMStudioLLM с новыми параметрами, добавлена динамическая обработка stop sequences для лучших ответов.
  - **Этап 4.1: Синхронизация конфигураций** - обновлены все файлы персонажа Нейри (conf.yaml, characters/neuro_pro.yaml, characters/neuri.yaml) с новым промптом и настройками, добавлены новые настройки агента и LLM во все конфигурации.
  - **Этап 5: Полная интеграция системы памяти в агент** - реализована автоматическая классификация и сохранение пользовательских сообщений в память, интеграция поиска релевантных воспоминаний перед каждым ответом агента, система отношений с пользователями (affinity, trust, interaction_count), автоматическая консолидация памяти каждые 30 минут, TTL очистка устаревших записей.
  - **Этап 5: Административные инструменты для памяти** - созданы полные REST API для управления памятью (/admin/memory/search, /admin/memory/export, /admin/memory/import, /admin/memory/delete, /admin/memory/edit), управления отношениями (/admin/relationship/get, /admin/relationship/update, /admin/relationship/list_recent), управления консолидацией (/admin/memory/consolidate, /admin/memory/deep_consolidation, /admin/memory/prune_session_ttl), WebSocket API для добавления воспоминаний и ручной консолидации.
  - **Этап 5: Система классификации и важности** - реализованы функции determine_memory_kind(), calculate_importance(), extract_tags(), detect_emotion() для автоматической классификации пользовательских сообщений, поддержка типов памяти USER, SELF, THIRD_PARTY, CHAT, EMOTIONS, OBJECTIVES.
  - **Этап 5: Интеграция с промптом** - система памяти автоматически добавляет релевантные воспоминания и информацию об отношениях в системный промпт агента, обеспечивая персонализированное общение на основе истории взаимодействий.